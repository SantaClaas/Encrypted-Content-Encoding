// HTTP Encrypted Content Encoding for Web Push as in RFC 8291


module WebPush

open System
open System.Buffers.Binary
open System.Security.Cryptography
open System.Text
open Microsoft.FSharp.Core

/// <summary>The padding delimiter octet as in RFC 8188/8291</summary>
[<Literal>]
let lastPaddingDelimiterOctet = 0x02uy

[<Literal>]
let paddingDelimiterOctet = 0x01uy

[<Literal>]
let RecordSize = 4096u

// F# modules do not initialize "static readonly" when in a class library so we have to do a workaround
[<Literal>]
let private nonceInfoString =
    "Content-Encoding: nonce\x00"

[<Literal>]
let private keyInfoString =
    "WebPush: info\x00"

let private getKeyInfo () = Encoding.ASCII.GetBytes keyInfoString

[<Literal>]
let private contentEncryptionKeyInfo =
    "Content-Encoding: aes128gcm\x00"

let getContentEncryptionKeyInfo () =
    Encoding.ASCII.GetBytes contentEncryptionKeyInfo

let getNonceInfo () =
    ASCIIEncoding.Default.GetBytes nonceInfoString

type Keys = Keys of privateKey: byte array * publicKey: byte array

type UserAgentKeys =
    { AuthenticationSecret: byte array
      PublicKey: byte array }

type ApplicationServerKeys =
    { PrivateKey: byte array
      PublicKey: byte array }

///<summary>Derives shared secret</summary>
let createPseudoRandomKey applicationServerPrivateKey (userAgentPublicKey: byte array) authenticationSecret =
    let privateKeyParameters =
        ECParameters(Curve = ECCurve.NamedCurves.nistP256, D = applicationServerPrivateKey)

    privateKeyParameters.Validate()

    use applicationServerKey =
        ECDiffieHellman.Create(privateKeyParameters)

    let userAgentKeyPoint =
        ECPoint(X = userAgentPublicKey[1..32], Y = userAgentPublicKey[33..])

    let userAgentKeyParameters =
        ECParameters(Curve = ECCurve.NamedCurves.nistP256, Q = userAgentKeyPoint)

    userAgentKeyParameters.Validate()

    use userAgentKey =
        ECDiffieHellman.Create(userAgentKeyParameters)

    // .NET creates ECDH, does the HMAC

    applicationServerKey.DeriveKeyFromHmac(userAgentKey.PublicKey, HashAlgorithmName.SHA256, authenticationSecret)

let createKeyInfo (userAgentPublicKey: byte array) (applicationServerPublicKey: byte array) =
    // F# ASCII string feature
    Array.concat [ getKeyInfo ()
                   userAgentPublicKey
                   applicationServerPublicKey ]

let createInputKeyingMaterial (pseudoRandomKey: byte array) (source: byte array) =
    HMACSHA256.HashData(pseudoRandomKey, source)

let createPseudoRandomKeyForContentEncryption (salt: byte array) (inputKeyingMaterial: byte array) =
    HMACSHA256.HashData(salt, inputKeyingMaterial)

let createContentEncryptionKey (pseudoRandomKey: byte array) (contentEncryptionInfo: byte array) =
    HMACSHA256.HashData(pseudoRandomKey, contentEncryptionInfo)[..15]

let createNonce (pseudoRandomKey: byte array) (nonceInfo: byte array) =
    HMACSHA256.HashData(pseudoRandomKey, nonceInfo)[..11]

// Key id can be the id both parties can identify the key with or the public key for web push notifications
let createContentCodingHeader (salt: byte array) (recordSize: byte array) (keyId: byte array) =
    //TODO assert lengths
    (*
+-----------+--------+-----------+---------------+
| salt (16) | rs (4) | idlen (1) | keyid (idlen) |
+-----------+--------+-----------+---------------+
*)
    Array.concat [ salt
                   recordSize
                   [| byte keyId.Length |]
                   keyId ]

let encryptPlainText (key: byte array) (plainText: byte array) (nonce: byte array) =
    use aesGcm = new AesGcm(key)

    let cipherText =
        Array.zeroCreate plainText.Length
    //TODO might need to XOR nonce with sequence number which is 0 since push messages only contain one record
    let tag = Array.zeroCreate 16
    aesGcm.Encrypt(nonce, plainText, cipherText, tag)
    // The tag is combined with the cipher text
    Array.concat [ cipherText; tag ]

// Private because it is context specific. The value needs to be generated by a function that puts out different
// values depending on the endianness of the system. If the value already has the correct endianness calling this
// might introduce error
let private ensureNetworkByteOrder (value: uint32) =
    if BitConverter.IsLittleEndian then
        BinaryPrimitives.ReverseEndianness value
    else
        value


let getRecordSizeBytes (recordSize: uint32) =
    recordSize
    // Bytes are in network byte order (big endian)
    |> ensureNetworkByteOrder
    |> BitConverter.GetBytes

let createContentCodingContent
    (plainText: byte array)
    (applicationServerPrivateKey: byte array)
    (applicationServerPublicKey: byte array)
    (userAgentPublicKey: byte array)
    (authenticationSecret: byte array)
    (salt: byte array)
    =
    // Create cypher text
    let pseudoRandomKey =
        createPseudoRandomKey applicationServerPrivateKey userAgentPublicKey authenticationSecret

    //TODO make keyInfoParameter = keyInfo + padding constant with "WebPush: info\x00\x01"B
    let keyInfo =
        createKeyInfo userAgentPublicKey applicationServerPublicKey

    let keyInfoParameter =
        Array.concat [ keyInfo
                       [| paddingDelimiterOctet |] ]

    let inputKeyingMaterial =
        createInputKeyingMaterial pseudoRandomKey keyInfoParameter

    let pseudoRandomKey =
        createPseudoRandomKeyForContentEncryption salt inputKeyingMaterial

    let nonceInfo = getNonceInfo ()

    let nonceInfoParameter =
        Array.concat [ nonceInfo
                       [| paddingDelimiterOctet |] ]

    let nonce =
        createNonce pseudoRandomKey nonceInfoParameter

    let plainTextAppended =
        Array.concat [ plainText
                       [| lastPaddingDelimiterOctet |] ]

    let contentEncryptionPseudoRandomKey =
        createPseudoRandomKeyForContentEncryption salt inputKeyingMaterial

    let contentEncryptionKeyInfo =
        getContentEncryptionKeyInfo ()

    let contentEncryptionKeyInfoParameter =
        Array.concat [ contentEncryptionKeyInfo
                       [| paddingDelimiterOctet |] ]

    let contentEncryptionKey =
        createContentEncryptionKey contentEncryptionPseudoRandomKey contentEncryptionKeyInfoParameter

    let cipherText =
        encryptPlainText contentEncryptionKey plainTextAppended nonce

    // Create coding header
    //TODO test different record sizes, check if possible
    let recordSizeBytes =
        getRecordSizeBytes RecordSize
 
    let header =
        createContentCodingHeader salt recordSizeBytes applicationServerPublicKey

    // Concatenate
    Array.concat [ header; cipherText ]

